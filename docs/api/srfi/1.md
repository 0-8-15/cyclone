# SRFI 1 - List library

The `(srfi 1)` provides a coherent and comprehensive set of list-processing procedures.

See the [SRFI document](http://srfi.schemers.org/srfi-1/srfi-1.html) for more information.

## Constructors
[`xcons`](#xcons)
[`cons*`](#cons)
[`make-list`](#make-list)
[`list-tabulate`](#list-tabulate)
[`list-copy`](#list-copy)
[`circular-list`](#circular-list-1)
[`iota`](#iota)

## Predicates
[`proper-list?`](#proper-list)
[`circular-list?`](#circular-list)
[`dotted-list?`](#dotted-list)
[`not-pair?`](#not-pair)
[`null-list?`](#null-list)
[`list=`](#list=)

## Selectors
[`first`](#first)
[`second`](#second)
[`third`](#third)
[`fourth`](#fourth)
[`fifth`](#fifth)
[`sixth`](#sixth)
[`seventh`](#seventh)
[`eighth`](#eighth)
[`ninth`](#ninth)
[`tenth`](#tenth)
[`car+cdr`](#carcdr)
[`take`](#take)
[`drop`](#drop)
[`take-right`](#take-right)
[`drop-right`](#drop-right)
[`take!`](#take-1)
[`drop-right!`](#drop-right-1)
[`split-at`](#split-at)
[`split-at!`](#split-at-1)
[`last`](#last)
[`last-pair`](#last-pair)

## Miscellaneous: length, append, concatenate, reverse, zip, and count
[`length+`](#length)
[`zip`](#zip)
[`unzip1`](#unzip1)
[`unzip2`](#unzip2)
[`unzip3`](#unzip3)
[`unzip4`](#unzip4)
[`unzip5`](#unzip5)
[`count`](#count)
[`append!`](#append)
[`append-reverse`](#append-reverse)
[`append-reverse!`](#append-reverse-1)
[`concatenate`](#concatenate)
[`concatenate!`](#concatenate-1)
[`reverse!`](#reverse)

## Fold, unfold, and map
[`unfold`](#unfold)
[`fold`](#fold)
[`pair-fold`](#pair-fold)
[`reduce`](#reduce)
[`unfold-right`](#unfold-right)
[`fold-right`](#fold-right)
[`pair-fold-right`](#pair-fold-right)
[`reduce-right`](#reduce-right)
[`append-map`](#append-map)
[`append-map!`](#append-map-1)
[`map!`](#map)
[`pair-for-each`](#pair-for-each)
[`filter-map`](#filter-map)
[`map-in-order`](#map-in-order)

## Filtering and partitioning
[`filter`](#filter)
[`partition`](#partition)
[`remove`](#remove)
[`filter!`](#filter-1)
[`partition!`](#partition-1)
[`remove!`](#remove-1)

## Searching
[`find`](#find)
[`find-tail`](#find-tail)
[`any`](#any)
[`every`](#every)
[`list-index`](#list-index)
[`take-while`](#take-while)
[`drop-while`](#drop-while)
[`take-while!`](#take-while-1)
[`span`](#span)
[`break`](#break)
[`span!`](#span-1)
[`break!`](#break-1)

## Deleting
[`delete`](#delete)
[`delete!`](#delete-1)
[`delete-duplicates`](#delete-duplicates)
[`delete-duplicates!`](#delete-duplicates-1)

## Association lists
[`alist-cons`](#alist-cons)
[`alist-copy`](#alist-copy)
[`alist-delete`](#alist-delete)
[`alist-delete!`](#alist-delete-1)

## Set operations on lists
[`lset<=`](#lset)
[`lset=`](#lset-1)
[`lset-adjoin`](#lset-adjoin)
[`lset-union`](#lset-union)
[`lset-intersection`](#lset-intersection)
[`lset-difference`](#lset-difference)
[`lset-xor`](#lset-xor)
[`lset-diff+intersection`](#lset-diffintersection)
[`lset-union!`](#lset-union)
[`lset-intersection!`](#lset-intersection-1)
[`lset-difference!`](#lset-difference-1)
[`lset-xor!`](#lset-xor-1)

# xcons

    (xcons d a)

Equivalent to:

    (lambda (d a) (cons a d))

Of utility only as a value to be conveniently passed to higher-order procedures.

   (xcons '(b c) 'a) => (a b c)

The name stands for "eXchanged CONS."

# cons*

    (cons* elt1 elt2 ...)

Like list, but the last argument provides the tail of the constructed list, returning

    (cons elt1 (cons elt2 (cons ... eltn)))

This function is called `list*` in Common Lisp and about half of the Schemes that provide it, and `cons*` in the other half.

    (cons* 1 2 3 4) => (1 2 3 . 4)
    (cons* 1) => 1

# make-list

    (make-list n)
    (make-list n fill)

Returns an n-element list, whose elements are all the value `fill`. If the fill argument is not given, the elements of the list may be arbitrary values.

    (make-list 4 'c) => (c c c c)

# list-tabulate

    (list-tabulate n init-proc)

Returns an n-element list. Element `i` of the list, where `0 <= i < n`, is produced by `(init-proc i)`. No guarantee is made about the dynamic order in which init-proc is applied to these indices.

    (list-tabulate 4 values) => (0 1 2 3)

# list-copy 

    (list-copy flist)

Copies the spine of the argument.

# circular-list

    (circular-list elt1 elt2 ...)

Constructs a circular list of the elements.

    (circular-list 'z 'q) => (z q z q z q ...)

# iota

    (iota count)
    (iota count start)
    (iota count start step)

Returns a list containing the elements

    (start start+step ... start+(count-1)*step)

The `start` and `step` parameters default to 0 and 1, respectively. This procedure takes its name from the APL primitive.

    (iota 5) => (0 1 2 3 4)
    (iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)

# proper-list?

    (proper-list? x)

Returns true iff `x` is a proper list -- a finite, nil-terminated list.

More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list:

    <proper-list> ::= ()                            (Empty proper list)
                  |   (cons <x> <proper-list>)      (Proper-list pair)

Note that this definition rules out circular lists. This function is required to detect this case and return false.

Nil-terminated lists are called "proper" lists by R7RS and Common Lisp. The opposite of proper is improper.

# circular-list?

    (circular-list? x)

True if `x` is a circular list. A circular list is a value such that for every `n >= 0`, the `n`th `cdr(x)` is a pair.

Terminology: The opposite of circular is finite.

    (not (circular-list? x)) = (or (proper-list? x) (dotted-list? x))

# dotted-list?

    (dotted-list? x)

True if `x` is a finite, non-nil-terminated list. That is, there exists an `n >= 0` such that the `n`th `cdr(x)` is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0.

    (not (dotted-list? x)) = (or (proper-list? x) (circular-list? x))

# not-pair?

    (not-pair? x)

Equivalent to:

    (lambda (x) (not (pair? x)))

Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted.

# null-list?

    (null-list? list)

`list` is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists.

# list=

    (list= elt= list1 ...)

Determines list equality, given an element-equality procedure. Proper list A equals proper list B if they are of the same length, and their corresponding elements are equal, as determined by `elt=`. If the element-comparison procedure's first argument is from listi, then its second argument is from listi+1, i.e. it is always called as `(elt= a b)` for a an element of list A, and b an element of list B.

In the n-ary case, every list `i` is compared to list `i+1` (as opposed, for example, to comparing list element `1` to every list element `i`, for `i>1`). If there are no list arguments at all, list= simply returns true.

It is an error to apply list= to anything except proper lists. While implementations may choose to extend it to circular lists, note that it cannot reasonably be extended to dotted lists, as it provides no way to specify an equality procedure for comparing the list terminators.

Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if list= is applied to three lists, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.

The equality procedure must be consistent with eq?. That is, it must be the case that

    (eq? x y) => (elt= x y).

Note that this implies that two lists which are eq? are always list=, as well; implementations may exploit this fact to "short-cut" the element-by-element comparisons.

    (list= eq?) => #t       ; Trivial cases
    (list= eq? '(a)) => #t

# first

    (first x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (first '(a b c d e f g h i j)) => a

# second

    (second x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (second '(a b c d e f g h i j)) => b

# third

    (third x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (third '(a b c d e f g h i j)) => c

# fourth

    (fourth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (fourth '(a b c d e f g h i j)) => d

# fifth

    (fifth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (fifth '(a b c d e f g h i j)) => e

# sixth

    (sixth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (sixth '(a b c d e f g h i j)) => f

# seventh

    (seventh x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (seventh '(a b c d e f g h i j)) => g

# eighth

    (eighth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (eighth '(a b c d e f g h i j)) => h

# ninth

    (ninth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (ninth '(a b c d e f g h i j)) => i

# tenth

    (tenth x)

Synonyms for `car`, `cadr`, `caddr`, `...`

    (tenth '(a b c d e f g h i j)) => j

# car+cdr

    (car+cdr pair)

The fundamental pair deconstructor:

    (lambda (p) (values (car p) (cdr p)))

# take

    (take x i)

`take` returns the first `i` elements of list `x`.

    (take '(a b c d e)  2) => (a b)

`x` may be any value -- a proper, circular, or dotted list:

    (take '(1 2 3 . d) 2) => (1 2)
    (take '(1 2 3 . d) 3) => (1 2 3)

For a legal i, take and drop partition the list in a manner which can be inverted with append:

    (append (take x i) (drop x i)) = x

If the argument is a list of non-zero length, `take` is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. `(take lis (length lis))`.

# drop

    (drop x i)

`drop` returns all but the first `i` elements of list `x`.

    (drop '(a b c d e)  2) => (c d e)

`x` may be any value -- a proper, circular, or dotted list:

    (drop '(1 2 3 . d) 2) => (3 . d)
    (drop '(1 2 3 . d) 3) => d

For a legal i, take and drop partition the list in a manner which can be inverted with append:

    (append (take x i) (drop x i)) = x

`drop` is exactly equivalent to performing `i` `cdr` operations on `x`; the returned value shares a common tail with `x`.

# take-right

    (take-right flist i)

`take-right` returns the last `i` elements of `flist`.

    (take-right '(a b c d e) 2) => (d e)

# drop-right

    (drop-right flist i)

`drop-right` returns all but the last `i` elements of `flist`.

    (drop-right '(a b c d e) 2) => (a b c)

# take!

    (take! x i)

`take!` is a "linear-update" variant of `take`: the procedure is allowed, but not required, to alter the argument list to produce the result.

If x is circular, take! may return a shorter-than-expected list:

    (take! (circular-list 1 3 5) 8) => (1 3)
    (take! (circular-list 1 3 5) 8) => (1 3 5 1 3 5 1 3)

# drop-right!

    (drop-right! flist i)

`drop-right!` is a "linear-update" variant of `drop-right`: the procedure is allowed, but not required, to alter the argument list to produce the result.

# split-at

    (split-at x i)

`split-at` splits the list `x` at index `i`, returning a list of the first `i` elements, and the remaining tail. It is equivalent to

    (values (take x i) (drop x i))

# split-at!

    (split-at! x i)

`split-at!` is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.

    (split-at '(a b c d e f g h) 3) =>
        (a b c)
            (d e f g h)

# last

    (last pair)

`last` returns the last element of the non-empty, finite list `pair`. 

    (last '(a b c)) => c

# last-pair

    (last-pair pair)

`last-pair` returns the last pair in the non-empty, finite list `pair`.

    (last-pair '(a b c)) => (c)

# length+

    (length+ clist)

`length+` returns the length of the argument, or `#f` when applied to a circular list.

The length of a proper list is a non-negative integer `n` such that `cdr` applied `n` times to the list produces the empty list.

# zip

    (zip clist1 clist2 ...)

This is equivalent to

    (lambda lists (apply map list lists))

If zip is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists.

    (zip '(one two three) 
         '(1 2 3)
              '(odd even odd even odd even odd even))
        => ((one 1 odd) (two 2 even) (three 3 odd))

    (zip '(1 2 3)) => ((1) (2) (3))

At least one of the argument lists must be finite:

    (zip '(3 1 4 1) (circular-list #f #t)) 
        => ((3 #f) (1 #t) (4 #f) (1 #t))

# unzip1

    (unzip1 list)

`unzip1` takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns `(map car lists)`.

# unzip2

    (unzip2 list)

`unzip2` takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. 

    (unzip2 '((1 one) (2 two) (3 three))) =>
        (1 2 3) 
            (one two three)

# unzip3

    (unzip3 list)

`unzip3` does the same as `unzip2` for the first three elements of the lists.

# unzip4

    (unzip4 list)

`unzip4` does the same as `unzip2` for the first four elements of the lists.

# unzip5

    (unzip5 list)

`unzip5` does the same as `unzip2` for the first five elements of the lists.

# count

    (count pred clist1 clist2)

`pred` is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. count is "iterative" in that it is guaranteed to apply pred to the list elements in a left-to-right order. The counting stops when the shortest list expires.

    (count even? '(3 1 4 1 5 9 2 5 6)) => 3
    (count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) => 3

At least one of the argument lists must be finite:

    (count < '(3 1 4 1) (circular-list 1 10)) => 2

# append!

    (append! list1 ...)

`append!` is the "linear-update" variant of `append` -- it is allowed, but not required, to alter cons cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter.

# append-reverse

    (append-reverse  rev-head tail)

`append-reverse` returns `(append (reverse rev-head) tail)`. It is provided because it is a common operation -- a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a reverse can frequently be rewritten as a recursion, dispensing with the reverse and append-reverse steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)


# append-reverse!

    (append-reverse! rev-head tail)

append-reverse! is just the linear-update variant -- it is allowed, but not required, to alter rev-head's cons cells to construct the result.

# concatenate

  (concatenate list-of-lists)

This function appends the elements of its argument together. That is, concatenate returns

    (apply append list-of-lists)

or, equivalently,

    (reduce-right append '() list-of-lists)

The last element of the input list may be any value at all.

# concatenate!

    (concatenate! list-of-lists)

`concatenate!` is the linear-update variant of `concatenate`.

# unfold

# fold

# pair-fold

# reduce

# unfold-right

# fold-right

# pair-fold-right

# reduce-right

# append-map

# append-map!

# map!

# pair-for-each

# filter-map

# map-in-order

# filter

# partition

# remove

# filter!

# partition!

# remove! 

# find

# find-tail

# any

# every

# list-index

# take-while

# drop-while

# take-while!

# span

# break

# span!

# break!

# delete

# delete!

# alist-cons

# alist-copy

# delete-duplicates

# delete-duplicates!

# alist-delete

# alist-delete!

# reverse! 

# lset<=

# lset=

# lset-adjoin  

# lset-union

# lset-intersection

# lset-difference

# lset-xor

# lset-diff+intersection

# lset-union!

# lset-intersection!

# lset-difference!

# lset-xor!


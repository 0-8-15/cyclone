// gcc test.c -L. -lcyclone -lm -I. -g -o test; ./test
/*
Program received signal SIGSEGV, Segmentation fault.
0x08050437 in __lambda_61 (argc=1, self_73163=0xbfff6d74, r_73103=0x8093084) at test.c:1267
warning: Source file is more recent than executable.
1267      if( !eq(boolean_f, r_73103) ){
    (gdb) bt
#0  0x08050437 in __lambda_61 (argc=1, self_73163=0xbfff6d74, r_73103=0x8093084) at test.c:1267
#1  0x08054963 in __lambda_2 (argc=2, _=0xbfff78bc, k_7324=0xbfff6d74, x_731=0x809307c) at test.c:1983
#2  0x080503ce in __lambda_62 (argc=1, self_73162=0xbfff6de8, r_73104=0x809307c) at test.c:1262
#3  0x08050291 in __lambda_63 (argc=1, self_73161=0xbfff6e58, c_7321=0x80934f4) at test.c:1245
#4  0x08050199 in __lambda_64 (argc=1, self_73160=0xbfff6f14, r_73102=0x80934f4) at test.c:1232
#5  0x08051b2c in __lambda_42 (argc=2, _=0xbfff787c, k_7377=0xbfff6f14, exp_7316=0x80934f4, env_7317=0x0) at test.c:1491
#6  0x0805009c in __lambda_65 (argc=1, self_73159=0xbfff6f88, r_73105=0x80934f4) at test.c:1216
#7  0x0804ff9f in __lambda_66 (argc=1, self_73158=0xbfff6ffc, r_73101=0xbfff700c) at test.c:1204
#8  0x0804fec2 in __lambda_67 (argc=1, _=0xbfff786c, k_73100=0xbfff70a8) at test.c:1192
#9  0x080515a8 in __lambda_47 (argc=1, self_73153=0xbfff7450, k_7388=0xbfff70a8) at test.c:1453
#10 0x080535f7 in __lambda_19 (argc=1, self_73133=0xbfff71c4, r_7349=0xbfff715c) at test.c:1798
#11 0x08052144 in __lambda_36 (argc=1, self_73137=0xbfff714c, r_7368=0xbfff715c) at test.c:1553
#12 0x08052075 in __lambda_37 (argc=2, _=0xbfff788c, k_7367=0xbfff71c4, h_7315=0xbfff7358) at test.c:1549
#13 0x080534d0 in __lambda_20 (argc=1, self_73132=0xbfff723c, result_7310=0xbfff724c) at test.c:1785
#14 0x080533a1 in __lambda_21 (argc=2, self_73131=0xbfff72b4, result_7310=0x809307c, my_91handler_7311=0xbfff7358) at test.c:1771
#15 0x0805329d in __lambda_22 (argc=1, self_73130=0xbfff7348, r_7348=0xbfff7358) at test.c:1755
#16 0x0805226a in __lambda_35 (argc=3, _=0xbfff7894, k_7347=0xbfff73d0, handler_738=0xbfff74e8, thunk_739=0xbfff7450) at test.c:1574
#17 0x080516e4 in __lambda_46 (argc=1, self_73154=0xbfff7440, r_7387=0xbfff7450) at test.c:1466
#18 0x08051510 in __lambda_48 (argc=1, self_73152=0xbfff74d8, r_7386=0xbfff74e8) at test.c:1449
#19 0x080508d2 in __lambda_58 (argc=1, self_73142=0xbfff7558, r_7384=0x8093500) at test.c:1323
#20 0x080507a1 in __lambda_59 (argc=2, self_73141=0xbfff7670, k_7382=0x809314c, k_7318=0xbfff75c4) at test.c:1302
#21 0x08054a4c in __lambda_1 (argc=2, _=0xbfff78c4, k=0x809314c, f=0xbfff7670) at test.c:1996
#22 0x0805199f in __lambda_43 (argc=1, self_73157=0xbfff7660, r_7381=0xbfff7670) at test.c:1486
#23 0x080506c1 in __lambda_60 (argc=1, _=0xbfff7874, k_7380=0x809314c) at test.c:1289
#24 0x0804fd59 in __lambda_68 (argc=1, _=0x804fcbb, r_73106=0x0) at test.c:1178
#25 0x0804fcb9 in __lambda_69 (argc=1, _=0x804fc47, r_73107=0x0) at test.c:1174
#26 0x0804fc45 in __lambda_70 (argc=0, _=0x804fbe5) at test.c:1170
#27 0x08055158 in c_entry_pt (argc=1, env=0xbffff124, cont=0xbffff11c) at test.c:2074
#28 0x080553c3 in do_dispatch (argc=1, func=0x8054afb <c_entry_pt>, clo=0xbffff124, b=0x80935c0) at runtime.c:99
#29 0x0804fb74 in main_main (stack_size=100000, heap_size=6000000, stack_base=0xbffff158 "\240\206\001") at runtime.h:1780
#30 0x080551dd in main (argc=1, argv=0xbffff204) at test.c:2081
*/
/**
 ** This file was automatically generated by the Cyclone scheme compiler
 **
 ** (c) 2014 Justin Ethier
 ** Version 0.0.1 (Pre-release)
 **
 **/

/* 
"---------------- input program:"
 */
/* 
((define (eval2 exp . env) exp)
 (define (test)
   (call/cc
     (lambda (k)
       (write (list 'result
                    (with-exception-handler
                      (lambda (obj)
                        (display "Error: ")
                        (cond ((pair? obj)
                               (for-each
                                 (lambda (o) (display o) (display " "))
                                 obj))
                              (else (display obj)))
                        (display "\n")
                        (k #t))
                      (lambda () (repl))))))))
 (define (repl)
   (display "cyclone> ")
   (let ((c (eval2 'done)))
     (cond ((not (eof-object? c)) (write c)) (else (exit 0)))))
 (test))
 */
/* 
"---------------- after macro expansion:"
 */
/* 
((define *Cyc-version-banner*
   "\n              :@ \n            @@@  \n          @@@@:  \n        `@@@@@+  \n       .@@@+@@@      Cyclone  \n       @@     @@     An experimental Scheme compiler\n      ,@             https://github.com/justinethier/cyclone\n      '@        \n      .@        \n       @@     #@     (c) 2014 Justin Ethier\n       `@@@#@@@.     Version 0.0.1 (Pre-release)\n        #@@@@@   \n        +@@@+    \n        @@#      \n      `@.  \n     \n")
 (define call-with-current-continuation call/cc)
 (define Cyc-bin-op
   (lambda (cmp x lst)
     (if (null? lst)
       #t
       (if (cmp x (car lst)) (Cyc-bin-op cmp (car lst) (cdr lst)) #f))))
 (define Cyc-bin-op-char
   (lambda (cmp c cs)
     (Cyc-bin-op
       (lambda (x y) (cmp (char->integer x) (char->integer y)))
       c
       cs)))
 (define char=? (lambda (c1 c2 . cs) (Cyc-bin-op-char = c1 (cons c2 cs))))
 (define char<? (lambda (c1 c2 . cs) (Cyc-bin-op-char < c1 (cons c2 cs))))
 (define char>? (lambda (c1 c2 . cs) (Cyc-bin-op-char > c1 (cons c2 cs))))
 (define char<=? (lambda (c1 c2 . cs) (Cyc-bin-op-char <= c1 (cons c2 cs))))
 (define char>=? (lambda (c1 c2 . cs) (Cyc-bin-op-char >= c1 (cons c2 cs))))
 (define char-upcase
   (lambda (c)
     (if (char-lower-case? c)
       (integer->char
         (- (char->integer c) (- (char->integer #\a) (char->integer #\A))))
       c)))
 (define char-downcase
   (lambda (c)
     (if (char-upper-case? c)
       (integer->char
         (+ (char->integer c) (- (char->integer #\a) (char->integer #\A))))
       c)))
 (define char-alphabetic? (lambda (c) (if (char>=? c #\A) (char<=? c #\z) #f)))
 (define char-upper-case? (lambda (c) (if (char>=? c #\A) (char<=? c #\Z) #f)))
 (define char-lower-case? (lambda (c) (if (char>=? c #\a) (char<=? c #\z) #f)))
 (define char-numeric?
   (lambda (c) (member c '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))))
 (define char-whitespace?
   (lambda (c) (member c '(#\tab #\space #\return #\newline))))
 (define digit-value
   (lambda (c)
     (if (char-numeric? c) (- (char->integer c) (char->integer #\0)) #f)))
 (define foldl
   (lambda (func accum lst)
     (if (null? lst) accum (foldl func (func (car lst) accum) (cdr lst)))))
 (define foldr
   (lambda (func end lst)
     (if (null? lst) end (func (car lst) (foldr func end (cdr lst))))))
 (define not (lambda (x) (if x #f #t)))
 (define list?
   (lambda (o)
     (define _list?
       (lambda (obj)
         (if (null? obj) #t (if (pair? obj) (_list? (cdr obj)) #f))))
     (if (Cyc-has-cycle? o) #t (_list? o))))
 (define zero? (lambda (n) (= n 0)))
 (define positive? (lambda (n) (> n 0)))
 (define negative? (lambda (n) (< n 0)))
 (define append
   (lambda lst
     (define append-2
       (lambda (inlist alist)
         (foldr (lambda (ap in) (cons ap in)) alist inlist)))
     (if (null? lst)
       lst
       (if (null? (cdr lst))
         (car lst)
         (foldl (lambda (a b) (append-2 b a)) (car lst) (cdr lst))))))
 (define list (lambda objs objs))
 (define make-list
   (lambda (k . fill)
     ((lambda (x make)
        ((lambda ()
           (set! x (if (null? fill) #f (car fill)))
           (set! make
             (lambda (n obj) (if (zero? n) '() (cons obj (make (- n 1) obj)))))
           (make k x))))
      #f
      #f)))
 (define list-copy (lambda (lst) (foldr (lambda (x y) (cons x y)) '() lst)))
 (define map
   (lambda (func lst) (foldr (lambda (x y) (cons (func x) y)) '() lst)))
 (define for-each
   (lambda (f lst)
     (if (null? lst) #t ((lambda () (f (car lst)) (for-each f (cdr lst)))))))
 (define list-tail
   (lambda (lst k) (if (zero? k) lst (list-tail (cdr lst) (- k 1)))))
 (define list-ref (lambda (lst k) (car (list-tail lst k))))
 (define list-set!
   (lambda (lst k obj) ((lambda (kth) (set-car! kth obj)) (list-tail lst k))))
 (define reverse (lambda (lst) (foldl cons '() lst)))
 (define boolean=? (lambda (b1 b2 . bs) (Cyc-obj=? boolean? b1 (cons b2 bs))))
 (define symbol=?
   (lambda (sym1 sym2 . syms) (Cyc-obj=? symbol? sym1 (cons sym2 syms))))
 (define Cyc-obj=?
   (lambda (type? obj objs)
     (if (type? obj)
       (call/cc
         (lambda (return)
           (for-each (lambda (o) (if (not (eq? o obj)) (return #f) #f)) objs)
           #t))
       #f)))
 (define make-string
   (lambda (k . fill)
     ((lambda (fill*) (list->string (apply make-list (cons k fill*))))
      (if (null? fill) '(#\space) fill))))
 (define error (lambda (msg . args) (raise (cons msg args))))
 (define raise
   (lambda (obj) ((Cyc-current-exception-handler) (list 'raised obj))))
 (define raise-continuable
   (lambda (obj) ((Cyc-current-exception-handler) (list 'continuable obj))))
 (define with-exception-handler
   (lambda (handler thunk)
     ((lambda (result my-handler)
        (Cyc-add-exception-handler my-handler)
        (set! result (thunk))
        (Cyc-remove-exception-handler)
        result)
      #f
      (lambda (obj)
        ((lambda (result continuable?)
           (Cyc-remove-exception-handler)
           (set! result (handler (cadr obj)))
           (if continuable? result (error "exception handler returned")))
         #f
         (if (pair? obj) (equal? (car obj) 'continuable) #f))))))
 (define *exception-handler-stack* '())
 (define Cyc-add-exception-handler
   (lambda (h)
     (set! *exception-handler-stack* (cons h *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda ()
     (if (not (null? *exception-handler-stack*))
       (set! *exception-handler-stack* (cdr *exception-handler-stack*))
       #f)))
 (define eval2 (lambda (exp . env) exp))
 (define test
   (lambda ()
     (call/cc
       (lambda (k)
         (write (list 'result
                      (with-exception-handler
                        (lambda (obj)
                          (display "Error: ")
                          (if (pair? obj)
                            (for-each
                              (lambda (o) (display o) (display " "))
                              obj)
                            (display obj))
                          (display "\n")
                          (k #t))
                        (lambda () (repl)))))))))
 (define repl
   (lambda ()
     (display "cyclone> ")
     ((lambda (c) (if (not (eof-object? c)) (write c) (exit 0)))
      (eval2 'done))))
 (test))
 */
/* 
"---------------- after processing globals"
 */
/* 
((define not (lambda (x) (if x #f #t)))
 (define list (lambda objs objs))
 (define for-each
   (lambda (f lst)
     (if (null? lst) #t ((lambda () (f (car lst)) (for-each f (cdr lst)))))))
 (define error (lambda (msg . args) (raise (cons msg args))))
 (define raise
   (lambda (obj) ((Cyc-current-exception-handler) (list 'raised obj))))
 (define with-exception-handler
   (lambda (handler thunk)
     ((lambda (result my-handler)
        (Cyc-add-exception-handler my-handler)
        (set! result (thunk))
        (Cyc-remove-exception-handler)
        result)
      #f
      (lambda (obj)
        ((lambda (result continuable?)
           (Cyc-remove-exception-handler)
           (set! result (handler (cadr obj)))
           (if continuable? result (error "exception handler returned")))
         #f
         (if (pair? obj) (equal? (car obj) 'continuable) #f))))))
 (define *exception-handler-stack* #f)
 (define Cyc-add-exception-handler
   (lambda (h)
     (set! *exception-handler-stack* (cons h *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda ()
     (if (not (null? *exception-handler-stack*))
       (set! *exception-handler-stack* (cdr *exception-handler-stack*))
       #f)))
 (define eval2 (lambda (exp . env) exp))
 (define test
   (lambda ()
     (call/cc
       (lambda (k)
         (write (list 'result
                      (with-exception-handler
                        (lambda (obj)
                          (display "Error: ")
                          (if (pair? obj)
                            (for-each
                              (lambda (o) (display o) (display " "))
                              obj)
                            (display obj))
                          (display "\n")
                          (k #t))
                        (lambda () (repl)))))))))
 (define repl
   (lambda ()
     (display "cyclone> ")
     ((lambda (c) (if (not (eof-object? c)) (write c) (exit 0)))
      (eval2 'done))))
 ((lambda () (set! *exception-handler-stack* '()) (test))))
 */
/* 
"---------------- after alpha conversion:"
 */
/* 
((define not (lambda (x$1) (if x$1 #f #t)))
 (define list (lambda objs$2 objs$2))
 (define for-each
   (lambda (f$3 lst$4)
     (if (null? lst$4)
       #t
       ((lambda () (f$3 (car lst$4)) (for-each f$3 (cdr lst$4)))))))
 (define error (lambda (msg$5 . args$6) (raise (cons msg$5 args$6))))
 (define raise
   (lambda (obj$7) ((Cyc-current-exception-handler) (list 'raised obj$7))))
 (define with-exception-handler
   (lambda (handler$8 thunk$9)
     ((lambda (result$10 my-handler$11)
        (Cyc-add-exception-handler my-handler$11)
        (set! result$10 (thunk$9))
        (Cyc-remove-exception-handler)
        result$10)
      #f
      (lambda (obj$12)
        ((lambda (result$13 continuable?$14)
           (Cyc-remove-exception-handler)
           (set! result$13 (handler$8 (cadr obj$12)))
           (if continuable?$14 result$13 (error "exception handler returned")))
         #f
         (if (pair? obj$12) (equal? (car obj$12) 'continuable) #f))))))
 (define *exception-handler-stack* #f)
 (define Cyc-add-exception-handler
   (lambda (h$15)
     (set! *exception-handler-stack* (cons h$15 *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda ()
     (if (not (null? *exception-handler-stack*))
       (set! *exception-handler-stack* (cdr *exception-handler-stack*))
       #f)))
 (define eval2 (lambda (exp$16 . env$17) exp$16))
 (define test
   (lambda ()
     (call/cc
       (lambda (k$18)
         (write (list 'result
                      (with-exception-handler
                        (lambda (obj$19)
                          (display "Error: ")
                          (if (pair? obj$19)
                            (for-each
                              (lambda (o$20) (display o$20) (display " "))
                              obj$19)
                            (display obj$19))
                          (display "\n")
                          (k$18 #t))
                        (lambda () (repl)))))))))
 (define repl
   (lambda ()
     (display "cyclone> ")
     ((lambda (c$21) (if (not (eof-object? c$21)) (write c$21) (exit 0)))
      (eval2 'done))))
 ((lambda () (set! *exception-handler-stack* '()) (test))))
 */
/* 
"---------------- after CPS:"
 */
/* 
((define call/cc (lambda (k f) (f k (lambda (_ result) (k result)))))
 (define not (lambda (k$24 x$1) (if x$1 (k$24 #f) (k$24 #t))))
 (define list (lambda (k$27 . objs$2) (k$27 objs$2)))
 (define for-each
   (lambda (k$30 f$3 lst$4)
     ((lambda (r$31)
        (if r$31
          (k$30 #t)
          ((lambda ()
             ((lambda (r$34)
                (f$3 (lambda (r$32)
                       ((lambda (r$33) (for-each k$30 f$3 r$33)) (cdr lst$4)))
                     r$34))
              (car lst$4))))))
      (null? lst$4))))
 (define error
   (lambda (k$37 msg$5 . args$6)
     ((lambda (r$38) (raise k$37 r$38)) (cons msg$5 args$6))))
 (define raise
   (lambda (k$41 obj$7)
     ((lambda (r$42)
        ((lambda (r$44) (list (lambda (r$43) (r$42 k$41 r$43)) r$44 obj$7))
         'raised))
      (Cyc-current-exception-handler))))
 (define with-exception-handler
   (lambda (k$47 handler$8 thunk$9)
     ((lambda (r$48)
        ((lambda (result$10 my-handler$11)
           (Cyc-add-exception-handler
             (lambda (r$49)
               (thunk$9
                 (lambda (r$52)
                   ((lambda (r$50)
                      (Cyc-remove-exception-handler
                        (lambda (r$51) (k$47 result$10))))
                    (set! result$10 r$52)))))
             my-handler$11))
         #f
         r$48))
      (lambda (k$53 obj$12)
        ((lambda (k$59)
           ((lambda (r$60)
              (if r$60
                ((lambda (r$61)
                   ((lambda (r$62) (k$59 (equal? r$61 r$62))) 'continuable))
                 (car obj$12))
                (k$59 #f)))
            (pair? obj$12)))
         (lambda (r$54)
           ((lambda (result$13 continuable?$14)
              (Cyc-remove-exception-handler
                (lambda (r$55)
                  ((lambda (r$58)
                     (handler$8
                       (lambda (r$57)
                         ((lambda (r$56)
                            (if continuable?$14
                              (k$53 result$13)
                              (error k$53 "exception handler returned")))
                          (set! result$13 r$57)))
                       r$58))
                   (cadr obj$12)))))
            #f
            r$54)))))))
 (define *exception-handler-stack* #f)
 (define Cyc-add-exception-handler
   (lambda (k$67 h$15)
     ((lambda (r$68) (k$67 (set! *exception-handler-stack* r$68)))
      (cons h$15 *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda (k$71)
     ((lambda (r$74)
        (not (lambda (r$72)
               (if r$72
                 ((lambda (r$73) (k$71 (set! *exception-handler-stack* r$73)))
                  (cdr *exception-handler-stack*))
                 (k$71 #f)))
             r$74))
      (null? *exception-handler-stack*))))
 (define eval2 (lambda (k$77 exp$16 . env$17) (k$77 exp$16)))
 (define test
   (lambda (k$80)
     ((lambda (r$81) (call/cc k$80 r$81))
      (lambda (k$82 k$18)
        ((lambda (r$84)
           ((lambda (r$86)
              ((lambda (r$87)
                 (with-exception-handler
                   (lambda (r$85)
                     (list (lambda (r$83) (k$82 (write r$83))) r$84 r$85))
                   r$86
                   r$87))
               (lambda (k$88) (repl k$88))))
            (lambda (k$89 obj$19)
              ((lambda (r$90)
                 ((lambda (k$93)
                    ((lambda (r$94)
                       (if r$94
                         ((lambda (r$95) (for-each k$93 r$95 obj$19))
                          (lambda (k$96 o$20)
                            ((lambda (r$97) (k$96 (display " ")))
                             (display o$20))))
                         (k$93 (display obj$19))))
                     (pair? obj$19)))
                  (lambda (r$91)
                    ((lambda (r$92) (k$18 k$89 #t)) (display "\n")))))
               (display "Error: ")))))
         'result)))))
 (define repl
   (lambda (k$100)
     ((lambda (r$101)
        ((lambda (r$105)
           (eval2 (lambda (r$102)
                    ((lambda (c$21)
                       ((lambda (r$104)
                          (not (lambda (r$103)
                                 (if r$103 (k$100 (write c$21)) (k$100 (exit 0))))
                               r$104))
                        (eof-object? c$21)))
                     r$102))
                  r$105))
         'done))
      (display "cyclone> "))))
 ((lambda ()
    ((lambda (r$107)
       ((lambda (r$106) (test %halt)) (set! *exception-handler-stack* r$107)))
     '()))))
 */
/* 
"---------------- after wrap-mutables:"
 */
/* 
((define call/cc (lambda (k f) (f k (lambda (_ result) (k result)))))
 (define not (lambda (k$24 x$1) (if x$1 (k$24 #f) (k$24 #t))))
 (define list (lambda (k$27 . objs$2) (k$27 objs$2)))
 (define for-each
   (lambda (k$30 f$3 lst$4)
     ((lambda (r$31)
        (if r$31
          (k$30 #t)
          ((lambda ()
             ((lambda (r$34)
                (f$3 (lambda (r$32)
                       ((lambda (r$33) (for-each k$30 f$3 r$33)) (cdr lst$4)))
                     r$34))
              (car lst$4))))))
      (null? lst$4))))
 (define error
   (lambda (k$37 msg$5 . args$6)
     ((lambda (r$38) (raise k$37 r$38)) (cons msg$5 args$6))))
 (define raise
   (lambda (k$41 obj$7)
     ((lambda (r$42)
        ((lambda (r$44) (list (lambda (r$43) (r$42 k$41 r$43)) r$44 obj$7))
         'raised))
      (Cyc-current-exception-handler))))
 (define with-exception-handler
   (lambda (k$47 handler$8 thunk$9)
     ((lambda (r$48)
        ((lambda (result$10 my-handler$11)
           ((lambda (result$10)
              (Cyc-add-exception-handler
                (lambda (r$49)
                  (thunk$9
                    (lambda (r$52)
                      ((lambda (r$50)
                         (Cyc-remove-exception-handler
                           (lambda (r$51) (k$47 (cell-get result$10)))))
                       (set-cell! result$10 r$52)))))
                my-handler$11))
            (cell result$10)))
         #f
         r$48))
      (lambda (k$53 obj$12)
        ((lambda (k$59)
           ((lambda (r$60)
              (if r$60
                ((lambda (r$61)
                   ((lambda (r$62) (k$59 (equal? r$61 r$62))) 'continuable))
                 (car obj$12))
                (k$59 #f)))
            (pair? obj$12)))
         (lambda (r$54)
           ((lambda (result$13 continuable?$14)
              ((lambda (result$13)
                 (Cyc-remove-exception-handler
                   (lambda (r$55)
                     ((lambda (r$58)
                        (handler$8
                          (lambda (r$57)
                            ((lambda (r$56)
                               (if continuable?$14
                                 (k$53 (cell-get result$13))
                                 (error k$53 "exception handler returned")))
                             (set-cell! result$13 r$57)))
                          r$58))
                      (cadr obj$12)))))
               (cell result$13)))
            #f
            r$54)))))))
 (define *exception-handler-stack* #f)
 (define Cyc-add-exception-handler
   (lambda (k$67 h$15)
     ((lambda (r$68) (k$67 (set-global! *exception-handler-stack* r$68)))
      (cons h$15 *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda (k$71)
     ((lambda (r$74)
        (not (lambda (r$72)
               (if r$72
                 ((lambda (r$73)
                    (k$71 (set-global! *exception-handler-stack* r$73)))
                  (cdr *exception-handler-stack*))
                 (k$71 #f)))
             r$74))
      (null? *exception-handler-stack*))))
 (define eval2 (lambda (k$77 exp$16 . env$17) (k$77 exp$16)))
 (define test
   (lambda (k$80)
     ((lambda (r$81) (call/cc k$80 r$81))
      (lambda (k$82 k$18)
        ((lambda (r$84)
           ((lambda (r$86)
              ((lambda (r$87)
                 (with-exception-handler
                   (lambda (r$85)
                     (list (lambda (r$83) (k$82 (write r$83))) r$84 r$85))
                   r$86
                   r$87))
               (lambda (k$88) (repl k$88))))
            (lambda (k$89 obj$19)
              ((lambda (r$90)
                 ((lambda (k$93)
                    ((lambda (r$94)
                       (if r$94
                         ((lambda (r$95) (for-each k$93 r$95 obj$19))
                          (lambda (k$96 o$20)
                            ((lambda (r$97) (k$96 (display " ")))
                             (display o$20))))
                         (k$93 (display obj$19))))
                     (pair? obj$19)))
                  (lambda (r$91)
                    ((lambda (r$92) (k$18 k$89 #t)) (display "\n")))))
               (display "Error: ")))))
         'result)))))
 (define repl
   (lambda (k$100)
     ((lambda (r$101)
        ((lambda (r$105)
           (eval2 (lambda (r$102)
                    ((lambda (c$21)
                       ((lambda (r$104)
                          (not (lambda (r$103)
                                 (if r$103 (k$100 (write c$21)) (k$100 (exit 0))))
                               r$104))
                        (eof-object? c$21)))
                     r$102))
                  r$105))
         'done))
      (display "cyclone> "))))
 ((lambda ()
    ((lambda (r$107)
       ((lambda (r$106) (test %halt))
        (set-global! *exception-handler-stack* r$107)))
     '()))))
 */
/* 
"---------------- after closure-convert:"
 */
/* 
((define call/cc
   (lambda (k f)
     ((%closure-ref f 0)
      f
      k
      (%closure
        (lambda (self$108 _ result)
          ((%closure-ref (%closure-ref self$108 1) 0)
           (%closure-ref self$108 1)
           result))
        k))))
 (define not
   (lambda (k$24 x$1)
     (if x$1 ((%closure-ref k$24 0) k$24 #f) ((%closure-ref k$24 0) k$24 #t))))
 (define list (lambda (k$27 . objs$2) ((%closure-ref k$27 0) k$27 objs$2)))
 (define for-each
   (lambda (k$30 f$3 lst$4)
     ((%closure
        (lambda (self$109 r$31)
          (if r$31
            ((%closure-ref (%closure-ref self$109 2) 0)
             (%closure-ref self$109 2)
             #t)
            ((%closure
               (lambda (self$110)
                 ((%closure
                    (lambda (self$111 r$34)
                      ((%closure-ref (%closure-ref self$111 1) 0)
                       (%closure-ref self$111 1)
                       (%closure
                         (lambda (self$112 r$32)
                           ((%closure
                              (lambda (self$113 r$33)
                                ((%closure-ref for-each 0)
                                 for-each
                                 (%closure-ref self$113 2)
                                 (%closure-ref self$113 1)
                                 r$33))
                              (%closure-ref self$112 1)
                              (%closure-ref self$112 2))
                            (cdr (%closure-ref self$112 3))))
                         (%closure-ref self$111 1)
                         (%closure-ref self$111 2)
                         (%closure-ref self$111 3))
                       r$34))
                    (%closure-ref self$110 1)
                    (%closure-ref self$110 2)
                    (%closure-ref self$110 3))
                  (car (%closure-ref self$110 3))))
               (%closure-ref self$109 1)
               (%closure-ref self$109 2)
               (%closure-ref self$109 3)))))
        f$3
        k$30
        lst$4)
      (null? lst$4))))
 (define error
   (lambda (k$37 msg$5 . args$6)
     ((%closure
        (lambda (self$114 r$38)
          ((%closure-ref raise 0) raise (%closure-ref self$114 1) r$38))
        k$37)
      (cons msg$5 args$6))))
 (define raise
   (lambda (k$41 obj$7)
     ((%closure
        (lambda (self$115 r$42)
          ((%closure
             (lambda (self$116 r$44)
               ((%closure-ref list 0)
                list
                (%closure
                  (lambda (self$117 r$43)
                    ((%closure-ref (%closure-ref self$117 2) 0)
                     (%closure-ref self$117 2)
                     (%closure-ref self$117 1)
                     r$43))
                  (%closure-ref self$116 1)
                  (%closure-ref self$116 3))
                r$44
                (%closure-ref self$116 2)))
             (%closure-ref self$115 1)
             (%closure-ref self$115 2)
             r$42)
           'raised))
        k$41
        obj$7)
      (Cyc-current-exception-handler))))
 (define with-exception-handler
   (lambda (k$47 handler$8 thunk$9)
     ((%closure
        (lambda (self$130 r$48)
          ((%closure
             (lambda (self$131 result$10 my-handler$11)
               ((%closure
                  (lambda (self$132 result$10)
                    ((%closure-ref Cyc-add-exception-handler 0)
                     Cyc-add-exception-handler
                     (%closure
                       (lambda (self$133 r$49)
                         ((%closure-ref (%closure-ref self$133 3) 0)
                          (%closure-ref self$133 3)
                          (%closure
                            (lambda (self$134 r$52)
                              ((%closure
                                 (lambda (self$135 r$50)
                                   ((%closure-ref Cyc-remove-exception-handler 0)
                                    Cyc-remove-exception-handler
                                    (%closure
                                      (lambda (self$136 r$51)
                                        ((%closure-ref (%closure-ref self$136 1) 0)
                                         (%closure-ref self$136 1)
                                         (cell-get (%closure-ref self$136 2))))
                                      (%closure-ref self$135 1)
                                      (%closure-ref self$135 2))))
                                 (%closure-ref self$134 1)
                                 (%closure-ref self$134 2))
                               (set-cell! (%closure-ref self$134 2) r$52)))
                            (%closure-ref self$133 1)
                            (%closure-ref self$133 2))))
                       (%closure-ref self$132 1)
                       result$10
                       (%closure-ref self$132 3))
                     (%closure-ref self$132 2)))
                  (%closure-ref self$131 1)
                  my-handler$11
                  (%closure-ref self$131 2))
                (cell result$10)))
             (%closure-ref self$130 1)
             (%closure-ref self$130 2))
           #f
           r$48))
        k$47
        thunk$9)
      (%closure
        (lambda (self$118 k$53 obj$12)
          ((%closure
             (lambda (self$126 k$59)
               ((%closure
                  (lambda (self$127 r$60)
                    (if r$60
                      ((%closure
                         (lambda (self$128 r$61)
                           ((%closure
                              (lambda (self$129 r$62)
                                ((%closure-ref (%closure-ref self$129 1) 0)
                                 (%closure-ref self$129 1)
                                 (equal? (%closure-ref self$129 2) r$62)))
                              (%closure-ref self$128 1)
                              r$61)
                            'continuable))
                         (%closure-ref self$127 1))
                       (car (%closure-ref self$127 2)))
                      ((%closure-ref (%closure-ref self$127 1) 0)
                       (%closure-ref self$127 1)
                       #f)))
                  k$59
                  (%closure-ref self$126 1))
                (pair? (%closure-ref self$126 1))))
             obj$12)
           (%closure
             (lambda (self$119 r$54)
               ((%closure
                  (lambda (self$120 result$13 continuable?$14)
                    ((%closure
                       (lambda (self$121 result$13)
                         ((%closure-ref Cyc-remove-exception-handler 0)
                          Cyc-remove-exception-handler
                          (%closure
                            (lambda (self$122 r$55)
                              ((%closure
                                 (lambda (self$123 r$58)
                                   ((%closure-ref (%closure-ref self$123 2) 0)
                                    (%closure-ref self$123 2)
                                    (%closure
                                      (lambda (self$124 r$57)
                                        ((%closure
                                           (lambda (self$125 r$56)
                                             (if (%closure-ref self$125 1)
                                               ((%closure-ref (%closure-ref self$125 2) 0)
                                                (%closure-ref self$125 2)
                                                (cell-get (%closure-ref self$125 3)))
                                               ((%closure-ref error 0)
                                                error
                                                (%closure-ref self$125 2)
                                                "exception handler returned")))
                                           (%closure-ref self$124 1)
                                           (%closure-ref self$124 2)
                                           (%closure-ref self$124 3))
                                         (set-cell! (%closure-ref self$124 3) r$57)))
                                      (%closure-ref self$123 1)
                                      (%closure-ref self$123 3)
                                      (%closure-ref self$123 4))
                                    r$58))
                                 (%closure-ref self$122 1)
                                 (%closure-ref self$122 2)
                                 (%closure-ref self$122 3)
                                 (%closure-ref self$122 5))
                               (cadr (%closure-ref self$122 4))))
                            (%closure-ref self$121 1)
                            (%closure-ref self$121 2)
                            (%closure-ref self$121 3)
                            (%closure-ref self$121 4)
                            result$13)))
                       continuable?$14
                       (%closure-ref self$120 1)
                       (%closure-ref self$120 2)
                       (%closure-ref self$120 3))
                     (cell result$13)))
                  (%closure-ref self$119 1)
                  (%closure-ref self$119 2)
                  (%closure-ref self$119 3))
                #f
                r$54))
             (%closure-ref self$118 1)
             k$53
             obj$12)))
        handler$8))))
 (define *exception-handler-stack* (%closure-ref #f 0) #f)
 (define Cyc-add-exception-handler
   (lambda (k$67 h$15)
     ((%closure
        (lambda (self$137 r$68)
          ((%closure-ref (%closure-ref self$137 1) 0)
           (%closure-ref self$137 1)
           (set-global! *exception-handler-stack* r$68)))
        k$67)
      (cons h$15 *exception-handler-stack*))))
 (define Cyc-remove-exception-handler
   (lambda (k$71)
     ((%closure
        (lambda (self$138 r$74)
          ((%closure-ref not 0)
           not
           (%closure
             (lambda (self$139 r$72)
               (if r$72
                 ((%closure
                    (lambda (self$140 r$73)
                      ((%closure-ref (%closure-ref self$140 1) 0)
                       (%closure-ref self$140 1)
                       (set-global! *exception-handler-stack* r$73)))
                    (%closure-ref self$139 1))
                  (cdr *exception-handler-stack*))
                 ((%closure-ref (%closure-ref self$139 1) 0)
                  (%closure-ref self$139 1)
                  #f)))
             (%closure-ref self$138 1))
           r$74))
        k$71)
      (null? *exception-handler-stack*))))
 (define eval2
   (lambda (k$77 exp$16 . env$17) ((%closure-ref k$77 0) k$77 exp$16)))
 (define test
   (lambda (k$80)
     ((%closure
        (lambda (self$157 r$81)
          ((%closure-ref call/cc 0) call/cc (%closure-ref self$157 1) r$81))
        k$80)
      (%closure
        (lambda (self$141 k$82 k$18)
          ((%closure
             (lambda (self$142 r$84)
               ((%closure
                  (lambda (self$152 r$86)
                    ((%closure
                       (lambda (self$154 r$87)
                         ((%closure-ref with-exception-handler 0)
                          with-exception-handler
                          (%closure
                            (lambda (self$155 r$85)
                              ((%closure-ref list 0)
                               list
                               (%closure
                                 (lambda (self$156 r$83)
                                   ((%closure-ref (%closure-ref self$156 1) 0)
                                    (%closure-ref self$156 1)
                                    (write r$83)))
                                 (%closure-ref self$155 1))
                               (%closure-ref self$155 2)
                               r$85))
                            (%closure-ref self$154 1)
                            (%closure-ref self$154 2))
                          (%closure-ref self$154 3)
                          r$87))
                       (%closure-ref self$152 1)
                       (%closure-ref self$152 2)
                       r$86)
                     (%closure
                       (lambda (self$153 k$88)
                         ((%closure-ref repl 0) repl k$88)))))
                  (%closure-ref self$142 2)
                  r$84)
                (%closure
                  (lambda (self$143 k$89 obj$19)
                    ((%closure
                       (lambda (self$144 r$90)
                         ((%closure
                            (lambda (self$147 k$93)
                              ((%closure
                                 (lambda (self$148 r$94)
                                   (if r$94
                                     ((%closure
                                        (lambda (self$151 r$95)
                                          ((%closure-ref for-each 0)
                                           for-each
                                           (%closure-ref self$151 1)
                                           r$95
                                           (%closure-ref self$151 2)))
                                        (%closure-ref self$148 1)
                                        (%closure-ref self$148 2))
                                      (%closure
                                        (lambda (self$149 k$96 o$20)
                                          ((%closure
                                             (lambda (self$150 r$97)
                                               ((%closure-ref (%closure-ref self$150 1) 0)
                                                (%closure-ref self$150 1)
                                                (display " ")))
                                             k$96)
                                           (display o$20)))))
                                     ((%closure-ref (%closure-ref self$148 1) 0)
                                      (%closure-ref self$148 1)
                                      (display (%closure-ref self$148 2)))))
                                 k$93
                                 (%closure-ref self$147 1))
                               (pair? (%closure-ref self$147 1))))
                            (%closure-ref self$144 3))
                          (%closure
                            (lambda (self$145 r$91)
                              ((%closure
                                 (lambda (self$146 r$92)
                                   ((%closure-ref (%closure-ref self$146 1) 0)
                                    (%closure-ref self$146 1)
                                    (%closure-ref self$146 2)
                                    #t))
                                 (%closure-ref self$145 1)
                                 (%closure-ref self$145 2))
                               (display "\n")))
                            (%closure-ref self$144 1)
                            (%closure-ref self$144 2))))
                       (%closure-ref self$143 1)
                       k$89
                       obj$19)
                     (display "Error: ")))
                  (%closure-ref self$142 1))))
             k$18
             k$82)
           'result))))))
 (define repl
   (lambda (k$100)
     ((%closure
        (lambda (self$158 r$101)
          ((%closure
             (lambda (self$159 r$105)
               ((%closure-ref eval2 0)
                eval2
                (%closure
                  (lambda (self$160 r$102)
                    ((%closure
                       (lambda (self$161 c$21)
                         ((%closure
                            (lambda (self$162 r$104)
                              ((%closure-ref not 0)
                               not
                               (%closure
                                 (lambda (self$163 r$103)
                                   (if r$103
                                     ((%closure-ref (%closure-ref self$163 2) 0)
                                      (%closure-ref self$163 2)
                                      (write (%closure-ref self$163 1)))
                                     ((%closure-ref (%closure-ref self$163 2) 0)
                                      (%closure-ref self$163 2)
                                      (exit 0))))
                                 (%closure-ref self$162 1)
                                 (%closure-ref self$162 2))
                               r$104))
                            c$21
                            (%closure-ref self$161 1))
                          (eof-object? c$21)))
                       (%closure-ref self$160 1))
                     r$102))
                  (%closure-ref self$159 1))
                r$105))
             (%closure-ref self$158 1))
           'done))
        k$100)
      (display "cyclone> "))))
 ((lambda ()
    ((lambda (r$107)
       ((lambda (r$106) ((%closure-ref test 0) test %halt))
        (set-global! *exception-handler-stack* r$107)))
     '()))))
 */
/* 
"---------------- C code:"
 */
#define DECLARE_GLOBALS  \
  static volatile object __glo_repl = nil; \
  static volatile object __glo_test = nil; \
  static volatile object __glo_eval2 = nil; \
  static volatile object __glo_Cyc_91remove_91exception_91handler = nil; \
  static volatile object __glo_Cyc_91add_91exception_91handler = nil; \
  static volatile object __glo__85exception_91handler_91stack_85 = nil; \
  static volatile object __glo_with_91exception_91handler = nil; \
  static volatile object __glo_raise = nil; \
  static volatile object __glo_error = nil; \
  static volatile object __glo_for_91each = nil; \
  static volatile object __glo__list = nil; \
  static volatile object __glo_not = nil; \
  static volatile object __glo_call_95cc = nil;

#define GC_GLOBALS \
{ \
  transp(__glo_repl); \
  transp(__glo_test); \
  transp(__glo_eval2); \
  transp(__glo_Cyc_91remove_91exception_91handler); \
  transp(__glo_Cyc_91add_91exception_91handler); \
  transp(__glo__85exception_91handler_91stack_85); \
  transp(__glo_with_91exception_91handler); \
  transp(__glo_raise); \
  transp(__glo_error); \
  transp(__glo_for_91each); \
  transp(__glo__list); \
  transp(__glo_not); \
  transp(__glo_call_95cc);}

#define funcall0(cfn) ((cfn)->fn)(0,cfn)
/* Return to continuation after checking for stack overflow. */
#define return_funcall0(cfn) \
{char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[0]; \
     GC(cfn,buf,0); return; \
 } else {funcall0((closure) (cfn)); return;}}

/* Evaluate an expression after checking for stack overflow. */
#define return_check0(_fn) { \
 char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[0];  \
     mclosure0(c1, _fn); \
     GC(&c1, buf, 0); return; \
 } else { (_fn)(0,(closure)_fn); }}

#define funcall1(cfn,a1) if (type_of(cfn) == cons_tag || prim(cfn)) { Cyc_apply(0, (closure)a1, cfn); } else { ((cfn)->fn)(1,cfn,a1);}
/* Return to continuation after checking for stack overflow. */
#define return_funcall1(cfn,a1) \
{char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[1]; buf[0] = a1;\
     GC(cfn,buf,1); return; \
 } else {funcall1((closure) (cfn),a1); return;}}

/* Evaluate an expression after checking for stack overflow. */
#define return_check1(_fn,a1) { \
 char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[1]; buf[0] = a1; \
     mclosure0(c1, _fn); \
     GC(&c1, buf, 1); return; \
 } else { (_fn)(1,(closure)_fn,a1); }}

#define funcall2(cfn,a1,a2) if (type_of(cfn) == cons_tag || prim(cfn)) { Cyc_apply(1, (closure)a1, cfn,a2); } else { ((cfn)->fn)(2,cfn,a1,a2);}
/* Return to continuation after checking for stack overflow. */
#define return_funcall2(cfn,a1,a2) \
{char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[2]; buf[0] = a1;buf[1] = a2;\
     GC(cfn,buf,2); return; \
 } else {funcall2((closure) (cfn),a1,a2); return;}}

/* Evaluate an expression after checking for stack overflow. */
#define return_check2(_fn,a1,a2) { \
 char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[2]; buf[0] = a1;buf[1] = a2; \
     mclosure0(c1, _fn); \
     GC(&c1, buf, 2); return; \
 } else { (_fn)(2,(closure)_fn,a1,a2); }}

#define funcall3(cfn,a1,a2,a3) if (type_of(cfn) == cons_tag || prim(cfn)) { Cyc_apply(2, (closure)a1, cfn,a2,a3); } else { ((cfn)->fn)(3,cfn,a1,a2,a3);}
/* Return to continuation after checking for stack overflow. */
#define return_funcall3(cfn,a1,a2,a3) \
{char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[3]; buf[0] = a1;buf[1] = a2;buf[2] = a3;\
     GC(cfn,buf,3); return; \
 } else {funcall3((closure) (cfn),a1,a2,a3); return;}}

/* Evaluate an expression after checking for stack overflow. */
#define return_check3(_fn,a1,a2,a3) { \
 char stack; \
 if (check_overflow(&stack,stack_limit1)) { \
     object buf[3]; buf[0] = a1;buf[1] = a2;buf[2] = a3; \
     mclosure0(c1, _fn); \
     GC(&c1, buf, 3); return; \
 } else { (_fn)(3,(closure)_fn,a1,a2,a3); }}

#include "runtime.h"
defsymbol(done, done);
defsymbol(result, result);
defsymbol(continuable, continuable);
defsymbol(raised, raised);
static void __lambda_70(int argc, closure _) ;
static void __lambda_69(int argc, closure _,object r_73107) ;
static void __lambda_68(int argc, closure _,object r_73106) ;
static void __lambda_67(int argc, closure _,object k_73100) ;
static void __lambda_66(int argc, object self_73158, object r_73101) ;
static void __lambda_65(int argc, object self_73159, object r_73105) ;
static void __lambda_64(int argc, object self_73160, object r_73102) ;
static void __lambda_63(int argc, object self_73161, object c_7321) ;
static void __lambda_62(int argc, object self_73162, object r_73104) ;
static void __lambda_61(int argc, object self_73163, object r_73103) ;
static void __lambda_60(int argc, closure _,object k_7380) ;
static void __lambda_59(int argc, object self_73141, object k_7382, object k_7318) ;
static void __lambda_58(int argc, object self_73142, object r_7384) ;
static void __lambda_57(int argc, object self_73143, object k_7389, object obj_7319) ;
static void __lambda_56(int argc, object self_73144, object r_7390) ;
static void __lambda_55(int argc, object self_73145, object r_7391) ;
static void __lambda_54(int argc, object self_73146, object r_7392) ;
static void __lambda_53(int argc, object self_73147, object k_7393) ;
static void __lambda_52(int argc, object self_73148, object r_7394) ;
static void __lambda_51(int argc, object self_73149, object k_7396, object o_7320) ;
static void __lambda_50(int argc, object self_73150, object r_7397) ;
static void __lambda_49(int argc, object self_73151, object r_7395) ;
static void __lambda_48(int argc, object self_73152, object r_7386) ;
static void __lambda_47(int argc, object self_73153, object k_7388) ;
static void __lambda_46(int argc, object self_73154, object r_7387) ;
static void __lambda_45(int argc, object self_73155, object r_7385) ;
static void __lambda_44(int argc, object self_73156, object r_7383) ;
static void __lambda_43(int argc, object self_73157, object r_7381) ;
static void __lambda_42(int argc, closure _,object k_7377, object exp_7316, object env_7317, ...) ;
static void __lambda_41(int argc, closure _,object k_7371) ;
static void __lambda_40(int argc, object self_73138, object r_7374) ;
static void __lambda_39(int argc, object self_73139, object r_7372) ;
static void __lambda_38(int argc, object self_73140, object r_7373) ;
static void __lambda_37(int argc, closure _,object k_7367, object h_7315) ;
static void __lambda_36(int argc, object self_73137, object r_7368) ;
static void __lambda_35(int argc, closure _,object k_7347, object handler_738, object thunk_739) ;
static void __lambda_34(int argc, object self_73118, object k_7353, object obj_7312) ;
static void __lambda_33(int argc, object self_73119, object r_7354) ;
static void __lambda_32(int argc, object self_73120, object result_7313, object continuable_127_7314) ;
static void __lambda_31(int argc, object self_73121, object result_7313) ;
static void __lambda_30(int argc, object self_73122, object r_7355) ;
static void __lambda_29(int argc, object self_73123, object r_7358) ;
static void __lambda_28(int argc, object self_73124, object r_7357) ;
static void __lambda_27(int argc, object self_73125, object r_7356) ;
static void __lambda_26(int argc, object self_73126, object k_7359) ;
static void __lambda_25(int argc, object self_73127, object r_7360) ;
static void __lambda_24(int argc, object self_73128, object r_7361) ;
static void __lambda_23(int argc, object self_73129, object r_7362) ;
static void __lambda_22(int argc, object self_73130, object r_7348) ;
static void __lambda_21(int argc, object self_73131, object result_7310, object my_91handler_7311) ;
static void __lambda_20(int argc, object self_73132, object result_7310) ;
static void __lambda_19(int argc, object self_73133, object r_7349) ;
static void __lambda_18(int argc, object self_73134, object r_7352) ;
static void __lambda_17(int argc, object self_73135, object r_7350) ;
static void __lambda_16(int argc, object self_73136, object r_7351) ;
static void __lambda_15(int argc, closure _,object k_7341, object obj_737) ;
static void __lambda_14(int argc, object self_73115, object r_7342) ;
static void __lambda_13(int argc, object self_73116, object r_7344) ;
static void __lambda_12(int argc, object self_73117, object r_7343) ;
static void __lambda_11(int argc, closure _,object k_7337, object msg_735, object args_736, ...) ;
static void __lambda_10(int argc, object self_73114, object r_7338) ;
static void __lambda_9(int argc, closure _,object k_7330, object f_733, object lst_734) ;
static void __lambda_8(int argc, object self_73109, object r_7331) ;
static void __lambda_7(int argc, object self_73110) ;
static void __lambda_6(int argc, object self_73111, object r_7334) ;
static void __lambda_5(int argc, object self_73112, object r_7332) ;
static void __lambda_4(int argc, object self_73113, object r_7333) ;
static void __lambda_3(int argc, closure _,object k_7327, object objs_732, ...) ;
static void __lambda_2(int argc, closure _,object k_7324, object x_731) ;
static void __lambda_1(int argc, closure _,object k, object f) ;
static void __lambda_0(int argc, object self_73108, object _191, object result) ;

static void __lambda_70(int argc, closure _) {
  return_check1(__lambda_69,nil);; 
}

static void __lambda_69(int argc, closure _,object r_73107) {
  return_check1(__lambda_68,global_set(__glo__85exception_91handler_91stack_85, r_73107));; 
}

static void __lambda_68(int argc, closure _,object r_73106) {
  return_funcall1(  __glo_test,  primitive__75halt);; 
}

static void __lambda_67(int argc, closure _,object k_73100) {
  
closureN_type c_73399;
c_73399.tag = closureN_tag;
 c_73399.fn = __lambda_66;
c_73399.num_elt = 1;
c_73399.elts = (object *)alloca(sizeof(object) * 1);
c_73399.elts[0] = k_73100;


make_string(c_73424, "cyclone> ");
return_funcall1((closure)&c_73399,  Cyc_display(&c_73424));; 
}

static void __lambda_66(int argc, object self_73158, object r_73101) {
  
closureN_type c_73401;
c_73401.tag = closureN_tag;
 c_73401.fn = __lambda_65;
c_73401.num_elt = 1;
c_73401.elts = (object *)alloca(sizeof(object) * 1);
c_73401.elts[0] = ((closureN)self_73158)->elts[0];

return_funcall1((closure)&c_73401,  quote_done);; 
}

static void __lambda_65(int argc, object self_73159, object r_73105) {
  
closureN_type c_73403;
c_73403.tag = closureN_tag;
 c_73403.fn = __lambda_64;
c_73403.num_elt = 1;
c_73403.elts = (object *)alloca(sizeof(object) * 1);
c_73403.elts[0] = ((closureN)self_73159)->elts[0];

  printf("debug(65) - ");
  Cyc_display(((closureN)self_73159)->elts[0]);
  printf("\n");

return_funcall2(  __glo_eval2,  &c_73403, r_73105);; 
}

static void __lambda_64(int argc, object self_73160, object r_73102) {
  
closureN_type c_73405;
c_73405.tag = closureN_tag;
 c_73405.fn = __lambda_63;
c_73405.num_elt = 1;
c_73405.elts = (object *)alloca(sizeof(object) * 1);
c_73405.elts[0] = ((closureN)self_73160)->elts[0];

  printf("debug(64) - ");
  Cyc_display(((closureN)self_73160)->elts[0]);
  printf("\n");

return_funcall1((closure)&c_73405,  r_73102);; 
}

static void __lambda_63(int argc, object self_73161, object c_7321) {
  
closureN_type c_73407;
c_73407.tag = closureN_tag;
 c_73407.fn = __lambda_62;
c_73407.num_elt = 2;
c_73407.elts = (object *)alloca(sizeof(object) * 2);
c_73407.elts[0] = c_7321;
c_73407.elts[1] = ((closureN)self_73161)->elts[0];

return_funcall1((closure)&c_73407,  Cyc_is_eof_object(c_7321));; 
}

static void __lambda_62(int argc, object self_73162, object r_73104) {
  
closureN_type c_73409;
c_73409.tag = closureN_tag;
 c_73409.fn = __lambda_61;
c_73409.num_elt = 2;
c_73409.elts = (object *)alloca(sizeof(object) * 2);
c_73409.elts[0] = ((closureN)self_73162)->elts[0];
c_73409.elts[1] = ((closureN)self_73162)->elts[1];

  printf("debug(62) - ");
  Cyc_display(((closureN)self_73162)->elts[1]);
  printf("\n");

return_funcall2(  __glo_not,  &c_73409, r_73104);; 
}

static void __lambda_61(int argc, object self_73163, object r_73103) {
  if( !eq(boolean_f, r_73103) ){ 
  return_funcall1(  ((closureN)self_73163)->elts[1],  Cyc_write(((closureN)self_73163)->elts[0]));
} else { 
  
  printf("debug: ");
  Cyc_display(((closureN)self_73163)->elts[1]);
  printf("\n");
make_int(c_73419, 0);
return_funcall1(  ((closureN)self_73163)->elts[1],  __halt(&c_73419));}
; 
}

static void __lambda_60(int argc, closure _,object k_7380) {
  
closureN_type c_73333;
c_73333.tag = closureN_tag;
 c_73333.fn = __lambda_43;
c_73333.num_elt = 1;
c_73333.elts = (object *)alloca(sizeof(object) * 1);
c_73333.elts[0] = k_7380;


mclosure0(c_73336, (function_type)__lambda_59);
return_funcall1((closure)&c_73333,  &c_73336);; 
}

static void __lambda_59(int argc, object self_73141, object k_7382, object k_7318) {
  
closureN_type c_73338;
c_73338.tag = closureN_tag;
 c_73338.fn = __lambda_58;
c_73338.num_elt = 2;
c_73338.elts = (object *)alloca(sizeof(object) * 2);
c_73338.elts[0] = k_7318;
c_73338.elts[1] = k_7382;

return_funcall1((closure)&c_73338,  quote_result);; 
}

static void __lambda_58(int argc, object self_73142, object r_7384) {
  
closureN_type c_73340;
c_73340.tag = closureN_tag;
 c_73340.fn = __lambda_48;
c_73340.num_elt = 2;
c_73340.elts = (object *)alloca(sizeof(object) * 2);
c_73340.elts[0] = ((closureN)self_73142)->elts[1];
c_73340.elts[1] = r_7384;


closureN_type c_73355;
c_73355.tag = closureN_tag;
 c_73355.fn = __lambda_57;
c_73355.num_elt = 1;
c_73355.elts = (object *)alloca(sizeof(object) * 1);
c_73355.elts[0] = ((closureN)self_73142)->elts[0];

return_funcall1((closure)&c_73340,  &c_73355);; 
}

static void __lambda_57(int argc, object self_73143, object k_7389, object obj_7319) {
  
closureN_type c_73357;
c_73357.tag = closureN_tag;
 c_73357.fn = __lambda_56;
c_73357.num_elt = 3;
c_73357.elts = (object *)alloca(sizeof(object) * 3);
c_73357.elts[0] = ((closureN)self_73143)->elts[0];
c_73357.elts[1] = k_7389;
c_73357.elts[2] = obj_7319;


make_string(c_73396, "Error: ");
return_funcall1((closure)&c_73357,  Cyc_display(&c_73396));; 
}

static void __lambda_56(int argc, object self_73144, object r_7390) {
  
closureN_type c_73359;
c_73359.tag = closureN_tag;
 c_73359.fn = __lambda_53;
c_73359.num_elt = 1;
c_73359.elts = (object *)alloca(sizeof(object) * 1);
c_73359.elts[0] = ((closureN)self_73144)->elts[2];


closureN_type c_73385;
c_73385.tag = closureN_tag;
 c_73385.fn = __lambda_55;
c_73385.num_elt = 2;
c_73385.elts = (object *)alloca(sizeof(object) * 2);
c_73385.elts[0] = ((closureN)self_73144)->elts[0];
c_73385.elts[1] = ((closureN)self_73144)->elts[1];

return_funcall1((closure)&c_73359,  &c_73385);; 
}

static void __lambda_55(int argc, object self_73145, object r_7391) {
  
closureN_type c_73387;
c_73387.tag = closureN_tag;
 c_73387.fn = __lambda_54;
c_73387.num_elt = 2;
c_73387.elts = (object *)alloca(sizeof(object) * 2);
c_73387.elts[0] = ((closureN)self_73145)->elts[0];
c_73387.elts[1] = ((closureN)self_73145)->elts[1];


make_string(c_73393, "\n");
return_funcall1((closure)&c_73387,  Cyc_display(&c_73393));; 
}

static void __lambda_54(int argc, object self_73146, object r_7392) {
  return_funcall2(  ((closureN)self_73146)->elts[0],  ((closureN)self_73146)->elts[1], boolean_t);; 
}

static void __lambda_53(int argc, object self_73147, object k_7393) {
  
closureN_type c_73361;
c_73361.tag = closureN_tag;
 c_73361.fn = __lambda_52;
c_73361.num_elt = 2;
c_73361.elts = (object *)alloca(sizeof(object) * 2);
c_73361.elts[0] = k_7393;
c_73361.elts[1] = ((closureN)self_73147)->elts[0];

return_funcall1((closure)&c_73361,  Cyc_is_cons(((closureN)self_73147)->elts[0]));; 
}

static void __lambda_52(int argc, object self_73148, object r_7394) {
  if( !eq(boolean_f, r_7394) ){ 
  
closureN_type c_73363;
c_73363.tag = closureN_tag;
 c_73363.fn = __lambda_49;
c_73363.num_elt = 2;
c_73363.elts = (object *)alloca(sizeof(object) * 2);
c_73363.elts[0] = ((closureN)self_73148)->elts[0];
c_73363.elts[1] = ((closureN)self_73148)->elts[1];


mclosure0(c_73367, (function_type)__lambda_51);
return_funcall1((closure)&c_73363,  &c_73367);
} else { 
  return_funcall1(  ((closureN)self_73148)->elts[0],  Cyc_display(((closureN)self_73148)->elts[1]));}
; 
}

static void __lambda_51(int argc, object self_73149, object k_7396, object o_7320) {
  
closureN_type c_73369;
c_73369.tag = closureN_tag;
 c_73369.fn = __lambda_50;
c_73369.num_elt = 1;
c_73369.elts = (object *)alloca(sizeof(object) * 1);
c_73369.elts[0] = k_7396;

return_funcall1((closure)&c_73369,  Cyc_display(o_7320));; 
}

static void __lambda_50(int argc, object self_73150, object r_7397) {
  
make_string(c_73374, " ");
return_funcall1(  ((closureN)self_73150)->elts[0],  Cyc_display(&c_73374));; 
}

static void __lambda_49(int argc, object self_73151, object r_7395) {
  return_funcall3(  __glo_for_91each,  ((closureN)self_73151)->elts[0], r_7395, ((closureN)self_73151)->elts[1]);; 
}

static void __lambda_48(int argc, object self_73152, object r_7386) {
  
closureN_type c_73342;
c_73342.tag = closureN_tag;
 c_73342.fn = __lambda_46;
c_73342.num_elt = 3;
c_73342.elts = (object *)alloca(sizeof(object) * 3);
c_73342.elts[0] = ((closureN)self_73152)->elts[0];
c_73342.elts[1] = ((closureN)self_73152)->elts[1];
c_73342.elts[2] = r_7386;


mclosure0(c_73353, (function_type)__lambda_47);
return_funcall1((closure)&c_73342,  &c_73353);; 
}

static void __lambda_47(int argc, object self_73153, object k_7388) {
  return_funcall1(  __glo_repl,  k_7388);; 
}

static void __lambda_46(int argc, object self_73154, object r_7387) {
  
closureN_type c_73344;
c_73344.tag = closureN_tag;
 c_73344.fn = __lambda_45;
c_73344.num_elt = 2;
c_73344.elts = (object *)alloca(sizeof(object) * 2);
c_73344.elts[0] = ((closureN)self_73154)->elts[0];
c_73344.elts[1] = ((closureN)self_73154)->elts[1];

return_funcall3(  __glo_with_91exception_91handler,  &c_73344, ((closureN)self_73154)->elts[2], r_7387);; 
}

static void __lambda_45(int argc, object self_73155, object r_7385) {
  
closureN_type c_73346;
c_73346.tag = closureN_tag;
 c_73346.fn = __lambda_44;
c_73346.num_elt = 1;
c_73346.elts = (object *)alloca(sizeof(object) * 1);
c_73346.elts[0] = ((closureN)self_73155)->elts[0];

return_funcall3(  __glo__list,  &c_73346, ((closureN)self_73155)->elts[1], r_7385);; 
}

static void __lambda_44(int argc, object self_73156, object r_7383) {
  return_funcall1(  ((closureN)self_73156)->elts[0],  Cyc_write(r_7383));; 
}

static void __lambda_43(int argc, object self_73157, object r_7381) {
  return_funcall2(  __glo_call_95cc,  ((closureN)self_73157)->elts[0], r_7381);; 
}

//static void __lambda_42(int argc, closure _,object k_7377, object exp_7316, object env_7317, ...) {
//load_varargs(env_7317, argc - 2);
//  return_funcall1(  k_7377,  exp_7316);; 
//}
static void __lambda_42(int argc, closure _,object k_7377, object exp_7316, object env_7317, ...) {
/* this illustrates the problem - since env is never passed, the
   address happens to be assigned somewhere else in memory, which
   just happens to be elts[0], hence why that location becomes null.
   probably need to enhance the compiler to introduce a new var
   rather than trying to assign to one that could potentially lead
   to memory corruption.
*/
//load_varargs(env_7317, argc - 2);
      list args = nil; 
    {
      int i; 
      object tmp; 
      va_list va; 
      if ((argc - 2) > 0) { 
        args = alloca(sizeof(cons_type)*(argc - 2)); 
        va_start(va, env_7317); 
        for (i = 0; i < (argc - 2); i++) { 
          if (i) { 
              tmp = va_arg(va, object); 
          } else { 
              tmp = env_7317; 
          } 
          args[i].tag = cons_tag; 
          args[i].cons_car = tmp; 
          args[i].cons_cdr = (i == ((argc - 2)-1)) ? nil : &args[i + 1]; 
        } 
        va_end(va); 
      } 
      env_7317 = args; 
    }
  return_funcall1(  k_7377,  exp_7316);; 
}

static void __lambda_41(int argc, closure _,object k_7371) {
  
closureN_type c_73314;
c_73314.tag = closureN_tag;
 c_73314.fn = __lambda_40;
c_73314.num_elt = 1;
c_73314.elts = (object *)alloca(sizeof(object) * 1);
c_73314.elts[0] = k_7371;

return_funcall1((closure)&c_73314,  Cyc_is_null(__glo__85exception_91handler_91stack_85));; 
}

static void __lambda_40(int argc, object self_73138, object r_7374) {
  
closureN_type c_73316;
c_73316.tag = closureN_tag;
 c_73316.fn = __lambda_39;
c_73316.num_elt = 1;
c_73316.elts = (object *)alloca(sizeof(object) * 1);
c_73316.elts[0] = ((closureN)self_73138)->elts[0];

return_funcall2(  __glo_not,  &c_73316, r_7374);; 
}

static void __lambda_39(int argc, object self_73139, object r_7372) {
  if( !eq(boolean_f, r_7372) ){ 
  
closureN_type c_73318;
c_73318.tag = closureN_tag;
 c_73318.fn = __lambda_38;
c_73318.num_elt = 1;
c_73318.elts = (object *)alloca(sizeof(object) * 1);
c_73318.elts[0] = ((closureN)self_73139)->elts[0];

return_funcall1((closure)&c_73318,  cdr(__glo__85exception_91handler_91stack_85));
} else { 
  return_funcall1(  ((closureN)self_73139)->elts[0],  boolean_f);}
; 
}

static void __lambda_38(int argc, object self_73140, object r_7373) {
  return_funcall1(  ((closureN)self_73140)->elts[0],  global_set(__glo__85exception_91handler_91stack_85, r_7373));; 
}

static void __lambda_37(int argc, closure _,object k_7367, object h_7315) {
  
closureN_type c_73304;
c_73304.tag = closureN_tag;
 c_73304.fn = __lambda_36;
c_73304.num_elt = 1;
c_73304.elts = (object *)alloca(sizeof(object) * 1);
c_73304.elts[0] = k_7367;


make_cons(c_73311,h_7315, __glo__85exception_91handler_91stack_85);
return_funcall1((closure)&c_73304,  &c_73311);; 
}

static void __lambda_36(int argc, object self_73137, object r_7368) {
  return_funcall1(  ((closureN)self_73137)->elts[0],  global_set(__glo__85exception_91handler_91stack_85, r_7368));; 
}

static void __lambda_35(int argc, closure _,object k_7347, object handler_738, object thunk_739) {
  
closureN_type c_73222;
c_73222.tag = closureN_tag;
 c_73222.fn = __lambda_22;
c_73222.num_elt = 2;
c_73222.elts = (object *)alloca(sizeof(object) * 2);
c_73222.elts[0] = k_7347;
c_73222.elts[1] = thunk_739;


closureN_type c_73248;
c_73248.tag = closureN_tag;
 c_73248.fn = __lambda_34;
c_73248.num_elt = 1;
c_73248.elts = (object *)alloca(sizeof(object) * 1);
c_73248.elts[0] = handler_738;

return_funcall1((closure)&c_73222,  &c_73248);; 
}

static void __lambda_34(int argc, object self_73118, object k_7353, object obj_7312) {
  
closureN_type c_73250;
c_73250.tag = closureN_tag;
 c_73250.fn = __lambda_26;
c_73250.num_elt = 1;
c_73250.elts = (object *)alloca(sizeof(object) * 1);
c_73250.elts[0] = obj_7312;


closureN_type c_73270;
c_73270.tag = closureN_tag;
 c_73270.fn = __lambda_33;
c_73270.num_elt = 3;
c_73270.elts = (object *)alloca(sizeof(object) * 3);
c_73270.elts[0] = ((closureN)self_73118)->elts[0];
c_73270.elts[1] = k_7353;
c_73270.elts[2] = obj_7312;

return_funcall1((closure)&c_73250,  &c_73270);; 
}

static void __lambda_33(int argc, object self_73119, object r_7354) {
  
closureN_type c_73272;
c_73272.tag = closureN_tag;
 c_73272.fn = __lambda_32;
c_73272.num_elt = 3;
c_73272.elts = (object *)alloca(sizeof(object) * 3);
c_73272.elts[0] = ((closureN)self_73119)->elts[0];
c_73272.elts[1] = ((closureN)self_73119)->elts[1];
c_73272.elts[2] = ((closureN)self_73119)->elts[2];

return_funcall2((closure)&c_73272,  boolean_f, r_7354);; 
}

static void __lambda_32(int argc, object self_73120, object result_7313, object continuable_127_7314) {
  
closureN_type c_73274;
c_73274.tag = closureN_tag;
 c_73274.fn = __lambda_31;
c_73274.num_elt = 4;
c_73274.elts = (object *)alloca(sizeof(object) * 4);
c_73274.elts[0] = continuable_127_7314;
c_73274.elts[1] = ((closureN)self_73120)->elts[0];
c_73274.elts[2] = ((closureN)self_73120)->elts[1];
c_73274.elts[3] = ((closureN)self_73120)->elts[2];


make_cell(c_73301,result_7313);
return_funcall1((closure)&c_73274,  &c_73301);; 
}

static void __lambda_31(int argc, object self_73121, object result_7313) {
  
closureN_type c_73276;
c_73276.tag = closureN_tag;
 c_73276.fn = __lambda_30;
c_73276.num_elt = 5;
c_73276.elts = (object *)alloca(sizeof(object) * 5);
c_73276.elts[0] = ((closureN)self_73121)->elts[0];
c_73276.elts[1] = ((closureN)self_73121)->elts[1];
c_73276.elts[2] = ((closureN)self_73121)->elts[2];
c_73276.elts[3] = ((closureN)self_73121)->elts[3];
c_73276.elts[4] = result_7313;

return_funcall1(  __glo_Cyc_91remove_91exception_91handler,  &c_73276);; 
}

static void __lambda_30(int argc, object self_73122, object r_7355) {
  
closureN_type c_73278;
c_73278.tag = closureN_tag;
 c_73278.fn = __lambda_29;
c_73278.num_elt = 4;
c_73278.elts = (object *)alloca(sizeof(object) * 4);
c_73278.elts[0] = ((closureN)self_73122)->elts[0];
c_73278.elts[1] = ((closureN)self_73122)->elts[1];
c_73278.elts[2] = ((closureN)self_73122)->elts[2];
c_73278.elts[3] = ((closureN)self_73122)->elts[4];

return_funcall1((closure)&c_73278,  cadr(((closureN)self_73122)->elts[3]));; 
}

static void __lambda_29(int argc, object self_73123, object r_7358) {
  
closureN_type c_73281;
c_73281.tag = closureN_tag;
 c_73281.fn = __lambda_28;
c_73281.num_elt = 3;
c_73281.elts = (object *)alloca(sizeof(object) * 3);
c_73281.elts[0] = ((closureN)self_73123)->elts[0];
c_73281.elts[1] = ((closureN)self_73123)->elts[2];
c_73281.elts[2] = ((closureN)self_73123)->elts[3];

return_funcall2(  ((closureN)self_73123)->elts[1],  &c_73281, r_7358);; 
}

static void __lambda_28(int argc, object self_73124, object r_7357) {
  
closureN_type c_73283;
c_73283.tag = closureN_tag;
 c_73283.fn = __lambda_27;
c_73283.num_elt = 3;
c_73283.elts = (object *)alloca(sizeof(object) * 3);
c_73283.elts[0] = ((closureN)self_73124)->elts[0];
c_73283.elts[1] = ((closureN)self_73124)->elts[1];
c_73283.elts[2] = ((closureN)self_73124)->elts[2];

return_funcall1((closure)&c_73283,  Cyc_set_car(((closureN)self_73124)->elts[2], r_7357));; 
}

static void __lambda_27(int argc, object self_73125, object r_7356) {
  if( !eq(boolean_f, ((closureN)self_73125)->elts[0]) ){ 
  return_funcall1(  ((closureN)self_73125)->elts[1],  cell_get(((closureN)self_73125)->elts[2]));
} else { 
  
make_string(c_73292, "exception handler returned");
return_funcall2(  __glo_error,  ((closureN)self_73125)->elts[1], &c_73292);}
; 
}

static void __lambda_26(int argc, object self_73126, object k_7359) {
  
closureN_type c_73252;
c_73252.tag = closureN_tag;
 c_73252.fn = __lambda_25;
c_73252.num_elt = 2;
c_73252.elts = (object *)alloca(sizeof(object) * 2);
c_73252.elts[0] = k_7359;
c_73252.elts[1] = ((closureN)self_73126)->elts[0];

return_funcall1((closure)&c_73252,  Cyc_is_cons(((closureN)self_73126)->elts[0]));; 
}

static void __lambda_25(int argc, object self_73127, object r_7360) {
  if( !eq(boolean_f, r_7360) ){ 
  
closureN_type c_73254;
c_73254.tag = closureN_tag;
 c_73254.fn = __lambda_24;
c_73254.num_elt = 1;
c_73254.elts = (object *)alloca(sizeof(object) * 1);
c_73254.elts[0] = ((closureN)self_73127)->elts[0];

return_funcall1((closure)&c_73254,  car(((closureN)self_73127)->elts[1]));
} else { 
  return_funcall1(  ((closureN)self_73127)->elts[0],  boolean_f);}
; 
}

static void __lambda_24(int argc, object self_73128, object r_7361) {
  
closureN_type c_73256;
c_73256.tag = closureN_tag;
 c_73256.fn = __lambda_23;
c_73256.num_elt = 2;
c_73256.elts = (object *)alloca(sizeof(object) * 2);
c_73256.elts[0] = ((closureN)self_73128)->elts[0];
c_73256.elts[1] = r_7361;

return_funcall1((closure)&c_73256,  quote_continuable);; 
}

static void __lambda_23(int argc, object self_73129, object r_7362) {
  return_funcall1(  ((closureN)self_73129)->elts[0],  equalp(((closureN)self_73129)->elts[1], r_7362));; 
}

static void __lambda_22(int argc, object self_73130, object r_7348) {
  
closureN_type c_73224;
c_73224.tag = closureN_tag;
 c_73224.fn = __lambda_21;
c_73224.num_elt = 2;
c_73224.elts = (object *)alloca(sizeof(object) * 2);
c_73224.elts[0] = ((closureN)self_73130)->elts[0];
c_73224.elts[1] = ((closureN)self_73130)->elts[1];

return_funcall2((closure)&c_73224,  boolean_f, r_7348);; 
}

static void __lambda_21(int argc, object self_73131, object result_7310, object my_91handler_7311) {
  
closureN_type c_73226;
c_73226.tag = closureN_tag;
 c_73226.fn = __lambda_20;
c_73226.num_elt = 3;
c_73226.elts = (object *)alloca(sizeof(object) * 3);
c_73226.elts[0] = ((closureN)self_73131)->elts[0];
c_73226.elts[1] = my_91handler_7311;
c_73226.elts[2] = ((closureN)self_73131)->elts[1];


make_cell(c_73247,result_7310);
return_funcall1((closure)&c_73226,  &c_73247);; 
}

static void __lambda_20(int argc, object self_73132, object result_7310) {
  
closureN_type c_73228;
c_73228.tag = closureN_tag;
 c_73228.fn = __lambda_19;
c_73228.num_elt = 3;
c_73228.elts = (object *)alloca(sizeof(object) * 3);
c_73228.elts[0] = ((closureN)self_73132)->elts[0];
c_73228.elts[1] = result_7310;
c_73228.elts[2] = ((closureN)self_73132)->elts[2];

return_funcall2(  __glo_Cyc_91add_91exception_91handler,  &c_73228, ((closureN)self_73132)->elts[1]);; 
}

static void __lambda_19(int argc, object self_73133, object r_7349) {
  
closureN_type c_73231;
c_73231.tag = closureN_tag;
 c_73231.fn = __lambda_18;
c_73231.num_elt = 2;
c_73231.elts = (object *)alloca(sizeof(object) * 2);
c_73231.elts[0] = ((closureN)self_73133)->elts[0];
c_73231.elts[1] = ((closureN)self_73133)->elts[1];

return_funcall1(  ((closureN)self_73133)->elts[2],  &c_73231);; 
}

static void __lambda_18(int argc, object self_73134, object r_7352) {
  
closureN_type c_73233;
c_73233.tag = closureN_tag;
 c_73233.fn = __lambda_17;
c_73233.num_elt = 2;
c_73233.elts = (object *)alloca(sizeof(object) * 2);
c_73233.elts[0] = ((closureN)self_73134)->elts[0];
c_73233.elts[1] = ((closureN)self_73134)->elts[1];

return_funcall1((closure)&c_73233,  Cyc_set_car(((closureN)self_73134)->elts[1], r_7352));; 
}

static void __lambda_17(int argc, object self_73135, object r_7350) {
  
closureN_type c_73235;
c_73235.tag = closureN_tag;
 c_73235.fn = __lambda_16;
c_73235.num_elt = 2;
c_73235.elts = (object *)alloca(sizeof(object) * 2);
c_73235.elts[0] = ((closureN)self_73135)->elts[0];
c_73235.elts[1] = ((closureN)self_73135)->elts[1];

return_funcall1(  __glo_Cyc_91remove_91exception_91handler,  &c_73235);; 
}

static void __lambda_16(int argc, object self_73136, object r_7351) {
  return_funcall1(  ((closureN)self_73136)->elts[0],  cell_get(((closureN)self_73136)->elts[1]));; 
}

static void __lambda_15(int argc, closure _,object k_7341, object obj_737) {
  
closureN_type c_73209;
c_73209.tag = closureN_tag;
 c_73209.fn = __lambda_14;
c_73209.num_elt = 2;
c_73209.elts = (object *)alloca(sizeof(object) * 2);
c_73209.elts[0] = k_7341;
c_73209.elts[1] = obj_737;

return_funcall1((closure)&c_73209,  Cyc_current_exception_handler());; 
}

static void __lambda_14(int argc, object self_73115, object r_7342) {
  
closureN_type c_73211;
c_73211.tag = closureN_tag;
 c_73211.fn = __lambda_13;
c_73211.num_elt = 3;
c_73211.elts = (object *)alloca(sizeof(object) * 3);
c_73211.elts[0] = ((closureN)self_73115)->elts[0];
c_73211.elts[1] = ((closureN)self_73115)->elts[1];
c_73211.elts[2] = r_7342;

return_funcall1((closure)&c_73211,  quote_raised);; 
}

static void __lambda_13(int argc, object self_73116, object r_7344) {
  
closureN_type c_73213;
c_73213.tag = closureN_tag;
 c_73213.fn = __lambda_12;
c_73213.num_elt = 2;
c_73213.elts = (object *)alloca(sizeof(object) * 2);
c_73213.elts[0] = ((closureN)self_73116)->elts[0];
c_73213.elts[1] = ((closureN)self_73116)->elts[2];

return_funcall3(  __glo__list,  &c_73213, r_7344, ((closureN)self_73116)->elts[1]);; 
}

static void __lambda_12(int argc, object self_73117, object r_7343) {
  return_funcall2(  ((closureN)self_73117)->elts[1],  ((closureN)self_73117)->elts[0], r_7343);; 
}

static void __lambda_11(int argc, closure _,object k_7337, object msg_735, object args_736, ...) {
load_varargs(args_736, argc - 2);
  
closureN_type c_73201;
c_73201.tag = closureN_tag;
 c_73201.fn = __lambda_10;
c_73201.num_elt = 1;
c_73201.elts = (object *)alloca(sizeof(object) * 1);
c_73201.elts[0] = k_7337;


make_cons(c_73206,msg_735, args_736);
return_funcall1((closure)&c_73201,  &c_73206);; 
}

static void __lambda_10(int argc, object self_73114, object r_7338) {
  return_funcall2(  __glo_raise,  ((closureN)self_73114)->elts[0], r_7338);; 
}

static void __lambda_9(int argc, closure _,object k_7330, object f_733, object lst_734) {
  
closureN_type c_73176;
c_73176.tag = closureN_tag;
 c_73176.fn = __lambda_8;
c_73176.num_elt = 3;
c_73176.elts = (object *)alloca(sizeof(object) * 3);
c_73176.elts[0] = f_733;
c_73176.elts[1] = k_7330;
c_73176.elts[2] = lst_734;

return_funcall1((closure)&c_73176,  Cyc_is_null(lst_734));; 
}

static void __lambda_8(int argc, object self_73109, object r_7331) {
  if( !eq(boolean_f, r_7331) ){ 
  return_funcall1(  ((closureN)self_73109)->elts[1],  boolean_t);
} else { 
  
closureN_type c_73180;
c_73180.tag = closureN_tag;
 c_73180.fn = __lambda_7;
c_73180.num_elt = 3;
c_73180.elts = (object *)alloca(sizeof(object) * 3);
c_73180.elts[0] = ((closureN)self_73109)->elts[0];
c_73180.elts[1] = ((closureN)self_73109)->elts[1];
c_73180.elts[2] = ((closureN)self_73109)->elts[2];

return_funcall0((closure)&c_73180);}
; 
}

static void __lambda_7(int argc, object self_73110) {
  
closureN_type c_73182;
c_73182.tag = closureN_tag;
 c_73182.fn = __lambda_6;
c_73182.num_elt = 3;
c_73182.elts = (object *)alloca(sizeof(object) * 3);
c_73182.elts[0] = ((closureN)self_73110)->elts[0];
c_73182.elts[1] = ((closureN)self_73110)->elts[1];
c_73182.elts[2] = ((closureN)self_73110)->elts[2];

return_funcall1((closure)&c_73182,  car(((closureN)self_73110)->elts[2]));; 
}

static void __lambda_6(int argc, object self_73111, object r_7334) {
  
closureN_type c_73185;
c_73185.tag = closureN_tag;
 c_73185.fn = __lambda_5;
c_73185.num_elt = 3;
c_73185.elts = (object *)alloca(sizeof(object) * 3);
c_73185.elts[0] = ((closureN)self_73111)->elts[0];
c_73185.elts[1] = ((closureN)self_73111)->elts[1];
c_73185.elts[2] = ((closureN)self_73111)->elts[2];

return_funcall2(  ((closureN)self_73111)->elts[0],  &c_73185, r_7334);; 
}

static void __lambda_5(int argc, object self_73112, object r_7332) {
  
closureN_type c_73187;
c_73187.tag = closureN_tag;
 c_73187.fn = __lambda_4;
c_73187.num_elt = 2;
c_73187.elts = (object *)alloca(sizeof(object) * 2);
c_73187.elts[0] = ((closureN)self_73112)->elts[0];
c_73187.elts[1] = ((closureN)self_73112)->elts[1];

return_funcall1((closure)&c_73187,  cdr(((closureN)self_73112)->elts[2]));; 
}

static void __lambda_4(int argc, object self_73113, object r_7333) {
  return_funcall3(  __glo_for_91each,  ((closureN)self_73113)->elts[1], ((closureN)self_73113)->elts[0], r_7333);; 
}

static void __lambda_3(int argc, closure _,object k_7327, object objs_732, ...) {
load_varargs(objs_732, argc - 1);
  return_funcall1(  k_7327,  objs_732);; 
}

static void __lambda_2(int argc, closure _,object k_7324, object x_731) {
  printf("debug(2) - ");
  Cyc_display(((closureN)k_7324)->elts[1]);
  printf("\n");
  if( !eq(boolean_f, x_731) ){ 
  return_funcall1(  k_7324,  boolean_f);
} else { 
  return_funcall1(  k_7324,  boolean_t);}
; 
}

static void __lambda_1(int argc, closure _,object k, object f) {
  
closureN_type c_73166;
c_73166.tag = closureN_tag;
 c_73166.fn = __lambda_0;
c_73166.num_elt = 1;
c_73166.elts = (object *)alloca(sizeof(object) * 1);
c_73166.elts[0] = k;

return_funcall2(  f,  k, &c_73166);; 
}

static void __lambda_0(int argc, object self_73108, object _191, object result) {
  return_funcall1(  ((closureN)self_73108)->elts[0],  result);; 
}


  static void c_entry_pt(argc, env,cont) int argc; closure env,cont; { 
  add_symbol(quote_done);
  add_symbol(quote_result);
  add_symbol(quote_continuable);
  add_symbol(quote_raised);
  mclosure0(c_73397, (function_type)__lambda_67); 
  __glo_repl = &c_73397; 
  mclosure0(c_73331, (function_type)__lambda_60); 
  __glo_test = &c_73331; 
  mclosure0(c_73329, (function_type)__lambda_42); 
  __glo_eval2 = &c_73329; 
  mclosure0(c_73312, (function_type)__lambda_41); 
  __glo_Cyc_91remove_91exception_91handler = &c_73312; 
  mclosure0(c_73302, (function_type)__lambda_37); 
  __glo_Cyc_91add_91exception_91handler = &c_73302; 
  mclosure0(c_73220, (function_type)__lambda_35); 
  __glo_with_91exception_91handler = &c_73220; 
  mclosure0(c_73207, (function_type)__lambda_15); 
  __glo_raise = &c_73207; 
  mclosure0(c_73199, (function_type)__lambda_11); 
  __glo_error = &c_73199; 
  mclosure0(c_73174, (function_type)__lambda_9); 
  __glo_for_91each = &c_73174; 
  mclosure0(c_73172, (function_type)__lambda_3); 
  __glo__list = &c_73172; 
  mclosure0(c_73169, (function_type)__lambda_2); 
  __glo_not = &c_73169; 
  mclosure0(c_73164, (function_type)__lambda_1); 
  __glo_call_95cc = &c_73164; 
  __glo__85exception_91handler_91stack_85 = boolean_f; 

  make_cvar(cvar_73431, (object *)&__glo_repl);make_cons(pair_73432, find_or_add_symbol("repl"), &cvar_73431);
  make_cvar(cvar_73433, (object *)&__glo_test);make_cons(pair_73434, find_or_add_symbol("test"), &cvar_73433);
  make_cvar(cvar_73435, (object *)&__glo_eval2);make_cons(pair_73436, find_or_add_symbol("eval2"), &cvar_73435);
  make_cvar(cvar_73437, (object *)&__glo_Cyc_91remove_91exception_91handler);make_cons(pair_73438, find_or_add_symbol("Cyc-remove-exception-handler"), &cvar_73437);
  make_cvar(cvar_73439, (object *)&__glo_Cyc_91add_91exception_91handler);make_cons(pair_73440, find_or_add_symbol("Cyc-add-exception-handler"), &cvar_73439);
  make_cvar(cvar_73441, (object *)&__glo__85exception_91handler_91stack_85);make_cons(pair_73442, find_or_add_symbol("*exception-handler-stack*"), &cvar_73441);
  make_cvar(cvar_73443, (object *)&__glo_with_91exception_91handler);make_cons(pair_73444, find_or_add_symbol("with-exception-handler"), &cvar_73443);
  make_cvar(cvar_73445, (object *)&__glo_raise);make_cons(pair_73446, find_or_add_symbol("raise"), &cvar_73445);
  make_cvar(cvar_73447, (object *)&__glo_error);make_cons(pair_73448, find_or_add_symbol("error"), &cvar_73447);
  make_cvar(cvar_73449, (object *)&__glo_for_91each);make_cons(pair_73450, find_or_add_symbol("for-each"), &cvar_73449);
  make_cvar(cvar_73451, (object *)&__glo__list);make_cons(pair_73452, find_or_add_symbol("list"), &cvar_73451);
  make_cvar(cvar_73453, (object *)&__glo_not);make_cons(pair_73454, find_or_add_symbol("not"), &cvar_73453);
  make_cvar(cvar_73455, (object *)&__glo_call_95cc);make_cons(pair_73456, find_or_add_symbol("call/cc"), &cvar_73455);
make_cons(c_73469, &pair_73432,nil);
make_cons(c_73468, &pair_73434, &c_73469);
make_cons(c_73467, &pair_73436, &c_73468);
make_cons(c_73466, &pair_73438, &c_73467);
make_cons(c_73465, &pair_73440, &c_73466);
make_cons(c_73464, &pair_73442, &c_73465);
make_cons(c_73463, &pair_73444, &c_73464);
make_cons(c_73462, &pair_73446, &c_73463);
make_cons(c_73461, &pair_73448, &c_73462);
make_cons(c_73460, &pair_73450, &c_73461);
make_cons(c_73459, &pair_73452, &c_73460);
make_cons(c_73458, &pair_73454, &c_73459);
make_cons(c_73457, &pair_73456, &c_73458);
Cyc_global_variables = &c_73457;  
    
    
    
    
    
    
    
    
    
    
    
    
    return_check0(__lambda_70);
}
main(int argc,char **argv)
{long stack_size = long_arg(argc,argv,"-s",STACK_SIZE);
 long heap_size = long_arg(argc,argv,"-h",HEAP_SIZE);
 global_stack_size = stack_size;
 global_heap_size = heap_size;
 main_main(stack_size,heap_size,(char *) &stack_size);
 return 0;}
